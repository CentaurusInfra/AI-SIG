package cudacollect

import (
	"bufio"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/prometheus/client_golang/prometheus"
)

const (
	alnairWorkSpace = "/var/lib/alnair/workspace/" //"/tmp/alnair/"
	metricFile      = "metrics.log"
	podFile         = "podInfo"
)

// cudaCollector has three metrics to report from metrics.log generated by intercept lib
type cudaCollector struct {
	alnairCuLaunchKernelCnt *prometheus.Desc
	alnairCuMemUsed         *prometheus.Desc
	alnairCuTokenCnt        *prometheus.Desc
}

// data struct for parsing metrics.log and PodInfo file
type CudaStat struct {
	Pid       float64
	KernelCnt float64
	MemUsed   float64
	TokenCnt  float64
	PodName   string
	Namespace string
}

func NewCollector(nodeName string) prometheus.Collector {
	return &cudaCollector{
		alnairCuLaunchKernelCnt: prometheus.NewDesc(
			//name of the metrics
			"alnair_cuda_launch_kernel_cnt",
			//help text
			"the count of cuLaunchKernel API called since the program starts",
			//the metric's variable label dimensions.
			[]string{"pid", "pod_name", "namespace"},
			//the metric's constant label dimensions.
			prometheus.Labels{"nodeName": nodeName},
		),
		alnairCuMemUsed: prometheus.NewDesc("alnair_cuda_mem_used",
			"Used GPU memory by cuMemAlloc", []string{"pid", "pod_name", "namespace"}, prometheus.Labels{"nodeName": nodeName},
		),
		alnairCuTokenCnt: prometheus.NewDesc("alnair_cuda_available_token",
			"Available token for launching cuda kernel, if token is used up, process needs to wait", []string{"pid", "pod_name", "namespace"}, prometheus.Labels{"nodeName": nodeName},
		),
	}
}

func (collector *cudaCollector) Describe(ch chan<- *prometheus.Desc) {
	ch <- collector.alnairCuLaunchKernelCnt
	ch <- collector.alnairCuMemUsed
	ch <- collector.alnairCuTokenCnt
}

func (collector *cudaCollector) Collect(ch chan<- prometheus.Metric) {
	//v2 := rand.Intn(1000)
	metrics := GetCudaStat()

	//ch <- prometheus.MustNewConstMetric(collector.alnairGmemUsed, prometheus.CounterValue, float64(v2))
	//it is OK to have an empty metrics when no processes, nothing reported under this metrics
	for _, g := range metrics {
		ch <- prometheus.MustNewConstMetric(collector.alnairCuLaunchKernelCnt, prometheus.CounterValue, g.KernelCnt, fmt.Sprint(g.Pid), g.PodName, g.Namespace)
		ch <- prometheus.MustNewConstMetric(collector.alnairCuMemUsed, prometheus.GaugeValue, g.MemUsed, fmt.Sprint(g.Pid), g.PodName, g.Namespace)
		ch <- prometheus.MustNewConstMetric(collector.alnairCuTokenCnt, prometheus.GaugeValue, g.TokenCnt, fmt.Sprint(g.Pid), g.PodName, g.Namespace)
	}
}

//each gpu pod's cuda stats are stored in /var/lib/alnair/workspace/<alnairID>/metrics.log
//iterate through each folder get three metrics, and podName and namespace from podInfo file in the same directory
func GetCudaStat() []CudaStat {
	var stats []CudaStat
	files, err := ioutil.ReadDir(alnairWorkSpace)
	if err != nil {
		log.Fatal(err)
	}

	for _, f := range files {
		metrics, err := parseMetrics(f.Name())
		if err != nil {
			continue
		}
		podName, namespace, err := parsePodInfo(f.Name())
		if err != nil {
			continue
		}
		//organize metrics and labels
		stats = append(stats, CudaStat{metrics[0], metrics[1], metrics[2], metrics[3], podName, namespace})
	}

	return stats
}

func parseMetrics(alnairID string) ([]float64, error) {
	var vals []string
	var metrics64 []float64
	alnairFolder := path.Join(alnairWorkSpace, alnairID)
	metricf, err := os.Open(path.Join(alnairFolder, metricFile))
	if err != nil {
		log.Printf("error opening file: %v\n", err)
		return metrics64, err
	}
	defer metricf.Close()
	//parse metrics.log file
	//pid:1234
	//kernel-cnt:1222222
	//mem-used:35000
	//token-cnt:5555
	scanner := bufio.NewScanner(metricf)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		vals = append(vals, strings.Split(scanner.Text(), ":")[1])
	}
	for _, m := range vals {
		if n, err := strconv.ParseFloat(m, 64); err == nil {
			metrics64 = append(metrics64, n)
		}
	}
	//expect: 4 elements
	if len(metrics64) != 4 {
		log.Printf("unexpected metrics64 %v\n", metrics64)
		return metrics64, errors.New("metrics parsing failed")
	}
	return metrics64, nil
}

func parsePodInfo(alnairID string) (string, string, error) {
	alnairFolder := path.Join(alnairWorkSpace, alnairID)
	podf, err := os.Open(path.Join(alnairFolder, podFile))
	if err != nil {
		log.Printf("error opening filev%s: %v\n", path.Join(alnairFolder, podFile), err)
		return "", "", err
	}
	defer podf.Close()
	//parse file podInfo, could add gpu_uuid on the 3rd line
	//podname:sharing-pod-1
	//namespace:default
	scanner := bufio.NewScanner(podf)
	scanner.Split(bufio.ScanLines)
	var vals []string
	for scanner.Scan() {
		vals = append(vals, strings.Split(scanner.Text(), ":")[1])
	}
	if len(vals) != 2 {
		log.Printf("unexpected podInfo format, vals:%v\n", vals)
		return "", "", errors.New("podInfo file format wrong")
	}
	return vals[0], vals[1], nil
}
